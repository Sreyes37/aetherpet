<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eco-Shift</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #0c0c0c;
            font-family: 'Consolas', 'Courier New', monospace;
            color: white;
            -webkit-user-select: none; /* Evitar selección de texto */
            -ms-user-select: none;
            user-select: none;
        }
        canvas {
            background-color: #1a1a2e;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(76, 209, 255, 0.5);
            border: 2px solid rgba(76, 209, 255, 0.8);
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <script>
    // ===================================================================================
    // CONFIGURACIÓN INICIAL Y ESTADOS DEL JUEGO
    // ===================================================================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let score = 0, highScore = 0, frameCount = 0;
    let gameState = 'start'; // 'start', 'shop', 'playing', 'bossFight', 'victory', 'gameOver'
    const GRAVITY = 0.4, JUMP_STRENGTH = -8, PARTICLE_DISTANCE = 40;
    const BOSS_TRIGGER_SCORE = 30;

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }
    
    // ===================================================================================
    // SISTEMA DE AUDIO
    // ===================================================================================
    let audioCtx;
    let soundEnabled = false;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        soundEnabled = true;
    }

    function playSound(type) {
        if (!soundEnabled) return;
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);

        switch (type) {
            case 'jump':
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
                break;
            case 'score':
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                break;
            case 'powerup':
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(500, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(1000, audioCtx.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
                break;
            case 'gameOver':
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.5);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
                break;
        }
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + 0.5);
    }

    // ===================================================================================
    // SISTEMA DE SKINS, ORBES Y DATOS GUARDADOS
    // ===================================================================================
    let totalOrbs = 0;
    let selectedSkin = 'default';
    let unlockedSkins = ['default'];

    const SKINS = {
        'default': { price: 0, draw: drawCircleSkin },
        'shards': { price: 10, draw: drawShardSkin },
        'squares': { price: 25, draw: drawSquareSkin }
    };

    function drawCircleSkin(ctx, x, y, radius, isLight) {
        ctx.fillStyle = isLight ? 'white' : 'black';
        ctx.shadowColor = isLight ? 'white' : 'black';
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
    }
    function drawShardSkin(ctx, x, y, radius, isLight) {
        ctx.fillStyle = isLight ? 'white' : 'black';
        ctx.shadowColor = isLight ? 'white' : 'black';
        ctx.beginPath();
        ctx.moveTo(x, y - radius);
        ctx.lineTo(x + radius, y + radius);
        ctx.lineTo(x - radius, y + radius);
        ctx.closePath();
        ctx.fill();
    }
    function drawSquareSkin(ctx, x, y, radius, isLight) {
        ctx.fillStyle = isLight ? 'white' : 'black';
        ctx.shadowColor = isLight ? 'white' : 'black';
        ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    function saveGameData() {
        const gameData = {
            highScore: highScore,
            totalOrbs: totalOrbs,
            selectedSkin: selectedSkin,
            unlockedSkins: unlockedSkins
        };
        localStorage.setItem('ecoShiftGameData', JSON.stringify(gameData));
    }
    function loadGameData() {
        const savedData = JSON.parse(localStorage.getItem('ecoShiftGameData'));
        if (savedData) {
            highScore = savedData.highScore || 0;
            totalOrbs = savedData.totalOrbs || 0;
            selectedSkin = savedData.selectedSkin || 'default';
            unlockedSkins = savedData.unlockedSkins || ['default'];
        }
    }

    // ===================================================================================
    // JUGADOR
    // ===================================================================================
    class Player {
        constructor() {
            this.x = canvas.width / 4; this.y = canvas.height / 2; this.radius = 15; this.velocityY = 0;
            this.isLightOnTop = true; this.isShielded = false; this.shieldTimer = 0;
            this.skinDrawer = SKINS[selectedSkin].draw;
        }
        update() { 
            this.velocityY += gravity; 
            this.y += this.velocityY; 
            if (this.y + this.radius + PARTICLE_DISTANCE > canvas.height || this.y - this.radius - PARTICLE_DISTANCE < 0) {
                gameOver();
            }
            if (this.shieldTimer > 0) {
                this.shieldTimer--;
            } else {
                this.isShielded = false;
            }
        }
        draw() {
            particles.push(new Particle(this.x, this.y, 3, `rgba(255, 255, 255, 0.5)`));
            const lightY = this.isLightOnTop ? this.y - PARTICLE_DISTANCE : this.y + PARTICLE_DISTANCE;
            const shadowY = this.isLightOnTop ? this.y + PARTICLE_DISTANCE : this.y - PARTICLE_DISTANCE;
            
            ctx.shadowBlur = 10;
            this.skinDrawer(ctx, this.x, lightY, this.radius, true);
            this.skinDrawer(ctx, this.x, shadowY, this.radius, false);
            
            if (this.isShielded) {
                const shieldColor = `rgba(76, 209, 255, ${0.5 + Math.sin(frameCount / 5) * 0.2})`;
                ctx.strokeStyle = shieldColor;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + PARTICLE_DISTANCE + 10, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
        }
        jumpAndSwap() { 
            if (gameState === 'playing' || gameState === 'bossFight') { 
                this.velocityY = JUMP_STRENGTH; 
                this.isLightOnTop = !this.isLightOnTop; 
                playSound('jump'); 
            } 
        }
    }
    let player = new Player();

    // ===================================================================================
    // OBSTÁCULOS, POWER-UPS Y ORBES
    // ===================================================================================
    let obstacles = [], powerUps = [], orbs = [];
    const OBSTACLE_WIDTH = 60, OBSTACLE_GAP = 200, OBSTACLE_SPAWN_RATE = 120;
    let obstacleSpeed = -2.5, gravity = GRAVITY;
    let slowMoTimer = 0;

    class Obstacle {
        constructor() {
            this.x = canvas.width; this.width = OBSTACLE_WIDTH;
            const minGapY = OBSTACLE_GAP / 2 + 50;
            const maxGapY = canvas.height - OBSTACLE_GAP / 2 - 50;
            this.gapCenterY = Math.random() * (maxGapY - minGapY) + minGapY;
            this.passed = false;
            this.hasPowerUp = Math.random() < 0.15;
            this.hasOrb = Math.random() < 0.05; // Orbes son más raros
            
            this.type = Math.random() < 0.2 && score > 10 ? 'moving' : 'static';
            this.moveSpeed = this.type === 'moving' ? (Math.random() - 0.5) * 2 : 0;
        }
        update() {
            this.x += obstacleSpeed;
            if (this.type === 'moving') {
                this.gapCenterY += this.moveSpeed;
                if (this.gapCenterY < OBSTACLE_GAP / 2 || this.gapCenterY > canvas.height - OBSTACLE_GAP / 2) {
                    this.moveSpeed *= -1;
                }
            }
        }
        draw() {
            ctx.fillStyle = 'white';
            ctx.fillRect(this.x, 0, this.width, this.gapCenterY - OBSTACLE_GAP / 2);
            ctx.fillStyle = 'black';
            ctx.fillRect(this.x, this.gapCenterY + OBSTACLE_GAP / 2, this.width, canvas.height);
        }
    }

    class PowerUp {
        constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.radius = 12; }
        update() { this.x += obstacleSpeed; }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(frameCount * 0.05);
            if (this.type === 'shield') {
                ctx.fillStyle = 'rgba(76, 209, 255, 0.8)';
                ctx.fillRect(-this.radius, -this.radius, this.radius * 2, this.radius * 2);
            } else { // slowmo
                ctx.fillStyle = 'rgba(255, 191, 0, 0.8)';
                ctx.beginPath();
                ctx.moveTo(0, -this.radius);
                ctx.lineTo(this.radius, this.radius);
                ctx.lineTo(-this.radius, this.radius);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }
    }

    class Orb {
        constructor(x, y) { this.x = x; this.y = y; this.radius = 10; }
        update() { this.x += obstacleSpeed; }
        draw() {
            const gradient = ctx.createRadialGradient(this.x, this.y, this.radius * 0.2, this.x, this.y, this.radius);
            gradient.addColorStop(0, `hsl(${frameCount % 360}, 100%, 70%)`);
            gradient.addColorStop(1, `hsl(${(frameCount + 180) % 360}, 100%, 50%)`);
            ctx.fillStyle = gradient;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
        }
    }

    function handleObstacles() {
        if (frameCount % OBSTACLE_SPAWN_RATE === 0) {
            const newObstacle = new Obstacle();
            obstacles.push(newObstacle);
            if (newObstacle.hasPowerUp && !newObstacle.hasOrb) {
                powerUps.push(new PowerUp(newObstacle.x + OBSTACLE_WIDTH / 2, newObstacle.gapCenterY, Math.random() < 0.5 ? "shield" : "slowmo"));
            }
            if (newObstacle.hasOrb) {
                orbs.push(new Orb(newObstacle.x + OBSTACLE_WIDTH / 2, newObstacle.gapCenterY));
            }
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
            obstacles[i].update();
            if (!obstacles[i].passed && obstacles[i].x + obstacles[i].width < player.x) {
                score++;
                obstacles[i].passed = true;
                playSound("score");
                if (score > 10 && score % 5 == 0 && obstacleSpeed > -5) {
                    obstacleSpeed -= 0.25;
                }
            }
        }
        obstacles = obstacles.filter(o => o.x + o.width > 0);
    }
    
    function handleCollectibles() {
        // PowerUps
        for (let i = powerUps.length - 1; i >= 0; i--) {
            powerUps[i].update();
            const dist = Math.hypot(player.x - powerUps[i].x, player.y - powerUps[i].y);
            if (dist < player.radius + powerUps[i].radius) {
                activatePowerUp(powerUps[i].type);
                powerUps.splice(i, 1);
            }
        }
        powerUps = powerUps.filter(p => p.x + p.radius > 0);

        // Orbes
        for (let i = orbs.length - 1; i >= 0; i--) {
            orbs[i].update();
            const dist = Math.hypot(player.x - orbs[i].x, player.y - orbs[i].y);
            if (dist < player.radius + orbs[i].radius) {
                totalOrbs++;
                playSound('powerup');
                orbs.splice(i, 1);
            }
        }
        orbs = orbs.filter(o => o.x + o.radius > 0);
    }

    function activatePowerUp(type) {
        playSound("powerup");
        if (type === "shield") {
            player.isShielded = true;
            player.shieldTimer = 300; // 5 seconds
        } else if (type === "slowmo") {
            slowMoTimer = 300;
        }
    }

    function updateTimers() {
        if (slowMoTimer > 0) {
            slowMoTimer--;
            const factor = 0.5;
            obstacleSpeed = -2.5 * factor;
            gravity = GRAVITY * factor;
            if (slowMoTimer === 0) {
                obstacleSpeed = -2.5 - (0.25 * Math.floor(score / 5));
                gravity = GRAVITY;
            }
        }
    }

    // ===================================================================================
    // JEFE FINAL
    // ===================================================================================
    let boss;
    class Boss {
        constructor() {
            this.x = canvas.width - 100; this.y = canvas.height / 2; this.width = 80; this.height = 200;
            this.health = 10; this.maxHealth = 10; this.attackTimer = 0; this.weakPoint = null;
        }
        update() {
            this.y = canvas.height / 2 + Math.sin(frameCount / 60) * (canvas.height / 4);
            this.attackTimer++;
            if (this.attackTimer % 120 === 0) {
                const type = Math.random() < 0.5 ? 'light' : 'shadow';
                const weakPointY = this.y + (Math.random() - 0.5) * this.height * 0.8;
                this.weakPoint = { x: this.x, y: weakPointY, type: type, radius: 20, active: true };
            }
        }
        draw() {
            const gradient = ctx.createLinearGradient(this.x, this.y - this.height / 2, this.x, this.y + this.height / 2);
            gradient.addColorStop(0, "white"); gradient.addColorStop(0.5, "grey"); gradient.addColorStop(1, "black");
            ctx.fillStyle = gradient;
            ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
            if (this.weakPoint && this.weakPoint.active) {
                ctx.fillStyle = this.weakPoint.type === 'light' ? 'white' : 'black';
                ctx.strokeStyle = this.weakPoint.type === 'light' ? 'black' : 'white';
                ctx.lineWidth = 2; ctx.beginPath();
                ctx.arc(this.weakPoint.x, this.weakPoint.y, this.weakPoint.radius, 0, Math.PI * 2);
                ctx.fill(); ctx.stroke();
            }
            ctx.fillStyle = 'red';
            ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2 - 20, this.width, 10);
            ctx.fillStyle = 'green';
            const healthWidth = (this.health / this.maxHealth) * this.width;
            ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2 - 20, healthWidth, 10);
        }
        takeDamage() {
            this.health--;
            this.weakPoint.active = false;
            shakeDuration = 10;
            if (this.health <= 0) {
                gameState = 'victory';
                for (let i = 0; i < 200; i++) {
                    particles.push(new Particle(this.x, this.y, Math.random() * 5, `hsl(${Math.random() * 360}, 100%, 50%)`, true));
                }
            }
        }
    }
    function handleBoss() {
        boss.update();
        if (boss.weakPoint && boss.weakPoint.active) {
            const lightY = player.isLightOnTop ? player.y - PARTICLE_DISTANCE : player.y + PARTICLE_DISTANCE;
            const shadowY = player.isLightOnTop ? player.y + PARTICLE_DISTANCE : player.y - PARTICLE_DISTANCE;
            const lightParticle = { x: player.x, y: lightY, radius: player.radius };
            const shadowParticle = { x: player.x, y: shadowY, radius: player.radius };
            const weakPoint = boss.weakPoint;
            if (weakPoint.type === 'light' && isCircleCollidingWithRect(lightParticle, { x: weakPoint.x - weakPoint.radius, y: weakPoint.y - weakPoint.radius, width: weakPoint.radius * 2, height: weakPoint.radius * 2 })) {
                boss.takeDamage();
            }
            if (weakPoint.type === 'shadow' && isCircleCollidingWithRect(shadowParticle, { x: weakPoint.x - weakPoint.radius, y: weakPoint.y - weakPoint.radius, width: weakPoint.radius * 2, height: weakPoint.radius * 2 })) {
                boss.takeDamage();
            }
        }
    }

    // ===================================================================================
    // EFECTOS VISUALES
    // ===================================================================================
    let particles = [], shakeDuration = 0, shakeIntensity = 5, backgroundLayers = [];
    class Particle {
        constructor(x, y, radius, color, isExplosion = false) {
            this.x = x; this.y = y; this.radius = radius; this.color = color; this.alpha = 1; this.isExplosion = isExplosion;
            if (isExplosion) {
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
            }
        }
        draw() {
            ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color; ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.restore();
        }
        update() {
            if (this.isExplosion) {
                this.x += this.vx; this.y += this.vy; this.alpha -= 0.01;
            } else {
                this.x += obstacleSpeed; this.alpha -= 0.03;
            }
        }
    }
    function handleParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw();
            if (particles[i].alpha <= 0) particles.splice(i, 1);
        }
    }
    function applyShake() {
        if (shakeDuration > 0) {
            ctx.save();
            const dx = (Math.random() - 0.5) * shakeIntensity;
            const dy = (Math.random() - 0.5) * shakeIntensity;
            ctx.translate(dx, dy);
            shakeDuration--;
        }
    }
    function setupBackground() {
        backgroundLayers = [];
        const layerSpeeds = [0.1, 0.2, 0.3];
        const layerCounts = [50, 40, 30];
        for (let i = 0; i < layerSpeeds.length; i++) {
            let stars = [];
            for (let j = 0; j < layerCounts[i]; j++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * (i + 1),
                    speed: layerSpeeds[i]
                });
            }
            backgroundLayers.push(stars);
        }
    }
    function handleBackground() {
        backgroundLayers.forEach(layer => {
            layer.forEach(star => {
                star.x += obstacleSpeed * star.speed;
                if (star.x < 0) star.x = canvas.width;
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + star.radius * 0.2})`;
                ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI); ctx.fill();
            });
        });
    }

    // ===================================================================================
    // LÓGICA DE JUEGO PRINCIPAL
    // ===================================================================================
    function checkCollisions() {
        if (player.isShielded || gameState !== 'playing') return;
        const lightY = player.isLightOnTop ? player.y - PARTICLE_DISTANCE : player.y + PARTICLE_DISTANCE;
        const shadowY = player.isLightOnTop ? player.y + PARTICLE_DISTANCE : player.y - PARTICLE_DISTANCE;
        for (let o of obstacles) {
            const topR = { x: o.x, y: 0, width: o.width, height: o.gapCenterY - OBSTACLE_GAP / 2 };
            const botR = { x: o.x, y: o.gapCenterY + OBSTACLE_GAP / 2, width: o.width, height: canvas.height };
            if (isCircleCollidingWithRect({ x: player.x, y: shadowY, radius: player.radius }, topR) ||
                isCircleCollidingWithRect({ x: player.x, y: lightY, radius: player.radius }, botR)) {
                gameOver();
            }
        }
    }
    function isCircleCollidingWithRect(circle, rect) {
        let testX = circle.x; let testY = circle.y;
        if (circle.x < rect.x) testX = rect.x;
        else if (circle.x > rect.x + rect.width) testX = rect.x + rect.width;
        if (circle.y < rect.y) testY = rect.y;
        else if (circle.y > rect.y + rect.height) testY = rect.y + rect.height;
        const distance = Math.sqrt((circle.x - testX) ** 2 + (circle.y - testY) ** 2);
        return distance <= circle.radius;
    }
    function startGame() { gameState = "playing"; player.jumpAndSwap(); }
    function gameOver() {
        if (gameState !== 'gameOver') {
            gameState = 'gameOver';
            shakeDuration = 20;
            playSound('gameOver');
            saveGameData();
        }
    }
    function resetGame() {
        loadGameData();
        player = new Player();
        obstacles = []; particles = []; powerUps = []; orbs = [];
        score = 0; frameCount = 0; slowMoTimer = 0;
        obstacleSpeed = -2.5; gravity = GRAVITY;
        boss = null;
        gameState = 'start';
    }

    // ===================================================================================
    // INTERFAZ DE USUARIO (UI)
    // ===================================================================================
    let shopButtons = {};
    function setupShopUI() {
        shopButtons = {};
        let i = 0;
        for (const skinId in SKINS) {
            shopButtons[skinId] = {
                x: 50, y: 150 + i * 100, width: canvas.width - 100, height: 80, id: skinId
            };
            i++;
        }
        shopButtons['back'] = { x: canvas.width / 2 - 50, y: 500, width: 100, height: 40 };
    }
    function drawUI() {
        ctx.fillStyle = 'white'; ctx.textAlign = 'center';
        if (gameState === 'start') {
            ctx.font = '30px Arial';
            ctx.fillText('Eco-Shift', canvas.width / 2, canvas.height / 2 - 100);
            ctx.font = '20px Arial';
            ctx.fillText('Pulsa para Empezar', canvas.width / 2, canvas.height / 2 - 50);
            ctx.font = '16px Arial';
            ctx.fillText(`Mejor Puntuación: ${highScore}`, canvas.width / 2, canvas.height / 2);
            ctx.fillText(`Orbes: ${totalOrbs}`, canvas.width - 70, 40);
            ctx.strokeStyle = 'white';
            ctx.strokeRect(canvas.width / 2 - 80, canvas.height / 2 + 40, 160, 40);
            ctx.font = '20px Arial';
            ctx.fillText('Personalizar', canvas.width / 2, canvas.height / 2 + 67);

        } else if (gameState === 'shop') {
            ctx.font = '30px Arial';
            ctx.fillText('Tienda de Aspectos', canvas.width / 2, 80);
            ctx.font = '20px Arial';
            ctx.fillText(`Orbes: ${totalOrbs}`, canvas.width / 2, 120);
            for (const key in shopButtons) {
                if (key === 'back') continue;
                const btn = shopButtons[key];
                const skin = SKINS[btn.id];
                ctx.strokeStyle = selectedSkin === btn.id ? 'lime' : 'white';
                ctx.lineWidth = selectedSkin === btn.id ? 3 : 1;
                ctx.strokeRect(btn.x, btn.y, btn.width, btn.height);
                SKINS[btn.id].draw(ctx, btn.x + 40, btn.y + 40, 15, true);
                SKINS[btn.id].draw(ctx, btn.x + 80, btn.y + 40, 15, false);
                ctx.font = '20px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(btn.id.charAt(0).toUpperCase() + btn.id.slice(1), btn.x + 120, btn.y + 35);
                ctx.font = '16px Arial';
                if (!unlockedSkins.includes(btn.id)) {
                    ctx.fillStyle = totalOrbs >= skin.price ? 'white' : 'red';
                }
                ctx.fillText(unlockedSkins.includes(btn.id) ? (selectedSkin === btn.id ? "Equipado" : "Seleccionar") : `Costo: ${skin.price}`, btn.x + 120, btn.y + 60);
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
            }
            const backBtn = shopButtons['back'];
            ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
            ctx.strokeRect(backBtn.x, backBtn.y, backBtn.width, backBtn.height);
            ctx.font = '20px Arial'; ctx.fillText('Volver', canvas.width / 2, backBtn.y + 27);

        } else if (gameState === 'victory') {
            ctx.font = '40px Arial';
            ctx.fillText('¡VICTORIA!', canvas.width / 2, canvas.height / 2);
            ctx.font = '20px Arial';
            ctx.fillText(`Puntuación Final: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
        } else {
            ctx.font = '60px Arial';
            ctx.fillText(score, canvas.width / 2, 80);
        }
        if (gameState === 'gameOver') {
            ctx.font = '40px Arial'; ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 20);
            ctx.font = '20px Arial'; ctx.fillText('Pulsa para Reiniciar', canvas.width / 2, canvas.height / 2 + 20);
            ctx.font = '16px Arial'; ctx.fillText(`Mejor Puntuación: ${highScore}`, canvas.width / 2, canvas.height / 2 + 60);
        }
    }
    
    // ===================================================================================
    // MANEJO DE INPUT
    // ===================================================================================
    function handleInput(e) {
        if (!soundEnabled) initAudio();
        
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        switch (gameState) {
            case 'start':
                if (mouseX > canvas.width / 2 - 80 && mouseX < canvas.width / 2 + 80 && mouseY > canvas.height / 2 + 40 && mouseY < canvas.height / 2 + 80) {
                    gameState = 'shop';
                    setupShopUI();
                } else {
                    startGame();
                }
                break;
            case 'shop':
                for (const key in shopButtons) {
                    const btn = shopButtons[key];
                    if (mouseX > btn.x && mouseX < btn.x + btn.width && mouseY > btn.y && mouseY < btn.y + btn.height) {
                        if (key === 'back') {
                             gameState = 'start';
                        } else {
                            if (unlockedSkins.includes(btn.id)) {
                                selectedSkin = btn.id;
                            } else if (totalOrbs >= SKINS[btn.id].price) {
                                totalOrbs -= SKINS[btn.id].price;
                                unlockedSkins.push(btn.id);
                                selectedSkin = btn.id;
                            }
                            saveGameData();
                        }
                        return;
                    }
                }
                break;
            case 'playing': case 'bossFight': player.jumpAndSwap(); break;
            case 'gameOver': case 'victory': resetGame(); saveGameData(); break;
        }
    }
    window.addEventListener('keydown', (e) => e.code === 'Space' && handleInput({ clientX: 0, clientY: 0 }));
    canvas.addEventListener('mousedown', handleInput);

    // ===================================================================================
    // BUCLES PRINCIPALES (UPDATE & DRAW)
    // ===================================================================================
    function update() {
        frameCount++;
        if (gameState === 'playing') {
            updateTimers();
            player.update();
            handleObstacles();
            handleCollectibles();
            checkCollisions();
            if (score >= BOSS_TRIGGER_SCORE && !boss) {
                gameState = 'bossFight';
                boss = new Boss();
                obstacles = []; powerUps = []; orbs = [];
            }
        } else if (gameState === 'bossFight') {
            player.update();
            handleBoss();
        } else if (gameState === 'victory') {
            handleParticles(); // Permite que la explosión se anime
        }
    }

    function draw() {
        if (gameState === 'victory') {
            ctx.fillStyle = `hsl(${frameCount % 360}, 50%, 15%)`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        applyShake();
        if (gameState !== 'victory') handleBackground();
        
        if (gameState === 'playing' || gameState === 'gameOver' || gameState === 'bossFight') {
            orbs.forEach(o => o.draw());
            obstacles.forEach(o => o.draw());
            powerUps.forEach(p => p.draw());
            player.draw();
        }
        if (gameState === 'bossFight') {
            boss.draw();
        }
        
        handleParticles();
        drawUI();
        if (shakeDuration > 0) ctx.restore();
    }

    // Iniciar el juego
    setupBackground();
    resetGame();
    gameLoop();
    </script>
</body>
</html>



